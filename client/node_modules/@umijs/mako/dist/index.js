var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if ((from && typeof from === 'object') || typeof from === 'function') {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
        });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (
  (target = mod != null ? __create(__getProtoOf(mod)) : {}),
  __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule
      ? __defProp(target, 'default', { value: mod, enumerable: true })
      : target,
    mod,
  )
);
var __toCommonJS = (mod) =>
  __copyProps(__defProp({}, '__esModule', { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  build: () => build2,
});
module.exports = __toCommonJS(src_exports);
var import_fs = __toESM(require('fs'));
var import_path = __toESM(require('path'));
var import_lodash = require('lodash');
var import_resolve = __toESM(require('resolve'));
var binding = __toESM(require('../binding'));
var import_forkTSChecker = require('./forkTSChecker');
var import_lessLoader = require('./lessLoader');
var import_rustPlugins = require('./rustPlugins');
var import_sassLoader = require('./sassLoader');
function blockStdout() {
  if (process.stdout._handle != null) {
    process.stdout._handle.setBlocking(true);
  }
  if (process.stderr._handle != null) {
    process.stderr._handle.setBlocking(true);
  }
}
async function build2(params) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
  blockStdout();
  params.config.plugins = params.config.plugins || [];
  params.config.resolve = params.config.resolve || {};
  const rustPlugins =
    (_a = params.config.experimental) == null ? void 0 : _a.rustPlugins;
  if (rustPlugins) {
    params.config.experimental.rustPlugins = await (0,
    import_rustPlugins.rustPluginResolver)(rustPlugins);
  }
  let makoConfig = {};
  let makoConfigPath = import_path.default.join(
    params.root,
    'mako.config.json',
  );
  if (import_fs.default.existsSync(makoConfigPath)) {
    try {
      makoConfig = JSON.parse(
        import_fs.default.readFileSync(makoConfigPath, 'utf-8'),
      );
    } catch (e) {
      throw new Error(`Parse mako.config.json failed: ${e.message}`);
    }
  }
  params.config.resolve.alias = [
    ...(((_b = makoConfig.resolve) == null ? void 0 : _b.alias) || []),
    ...(((_c = params.config.resolve) == null ? void 0 : _c.alias) || []),
    // we still need @swc/helpers
    // since features like decorator or legacy browser support will
    // inject helper functions in the build transform step
    [
      '@swc/helpers',
      import_path.default.dirname(require.resolve('@swc/helpers/package.json')),
    ],
    [
      'node-libs-browser-okam',
      import_path.default.dirname(
        require.resolve('node-libs-browser-okam/package.json'),
      ),
    ],
    [
      'react-refresh',
      import_path.default.dirname(
        require.resolve('react-refresh/package.json'),
      ),
    ],
    [
      'react-error-overlay',
      import_path.default.dirname(
        require.resolve('react-error-overlay/package.json'),
      ),
    ],
  ];
  const lessPluginAlias =
    ((_e = (_d = params.config.resolve) == null ? void 0 : _d.alias) == null
      ? void 0
      : _e.reduce((accumulator, currentValue) => {
          accumulator[currentValue[0]] = currentValue[1];
          return accumulator;
        }, {})) || {};
  let less = (0, import_lessLoader.lessLoader)(null, {
    modifyVars:
      ((_f = params.config.less) == null ? void 0 : _f.modifyVars) || {},
    globalVars: (_g = params.config.less) == null ? void 0 : _g.globalVars,
    math: (_h = params.config.less) == null ? void 0 : _h.math,
    sourceMap:
      ((_i = params.config.less) == null ? void 0 : _i.sourceMap) || false,
    plugins: [
      ['less-plugin-resolve', { aliases: lessPluginAlias }],
      ...(((_j = params.config.less) == null ? void 0 : _j.plugins) || []),
    ],
  });
  params.config.plugins.push({
    name: 'less',
    async load(filePath) {
      let lessResult = await less.render(filePath);
      if (lessResult) {
        return lessResult;
      }
    },
    generateEnd() {
      if (!params.watch) {
        less.terminate();
      }
    },
  });
  if (
    (makoConfig == null ? void 0 : makoConfig.sass) ||
    ((_k = params.config) == null ? void 0 : _k.sass)
  ) {
    const sassOpts = {
      ...((makoConfig == null ? void 0 : makoConfig.sass) || {}),
      ...(((_l = params.config) == null ? void 0 : _l.sass) || {}),
    };
    let sass = (0, import_sassLoader.sassLoader)(null, sassOpts);
    params.config.plugins.push({
      name: 'sass',
      async load(filePath) {
        let sassResult = await sass.render(filePath);
        if (sassResult) {
          return sassResult;
        }
      },
      generateEnd() {
        if (!params.watch) {
          sass.terminate();
        }
      },
    });
  }
  if (process.env.DUMP_MAKO_CONFIG) {
    const configFile = import_path.default.join(
      params.root,
      'mako.config.json',
    );
    import_fs.default.writeFileSync(
      configFile,
      JSON.stringify(params.config, null, 2),
    );
  }
  if (process.env.XCODE_PROFILE) {
    await new Promise((resolve2) => {
      const readline = require('readline');
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
      });
      rl.question(
        `Xcode profile enabled. Current process ${process.title} (${process.pid}) . Press Enter to continue...
`,
        () => {
          rl.close();
          resolve2();
        },
      );
    });
  }
  let plugins = params.config.plugins;
  plugins = plugins.map((plugin) => {
    if (typeof plugin === 'string') {
      let fn = require(
        import_resolve.default.sync(plugin, {
          basedir: params.root,
        }),
      );
      return fn.default || fn;
    } else {
      return plugin;
    }
  });
  (_m = makoConfig.plugins) == null
    ? void 0
    : _m.forEach((plugin) => {
        if (typeof plugin === 'string') {
          let fn = require(
            import_resolve.default.sync(plugin, {
              basedir: params.root,
            }),
          );
          plugins.push(fn.default || fn);
        } else {
          throw new Error(
            `Invalid plugin: ${plugin} in mako.config.json, only support string type plugin here.`,
          );
        }
      });
  params.config = (0, import_lodash.omit)(params.config, [
    'less',
    'sass',
    'forkTSChecker',
    'plugins',
  ]);
  await binding.build({
    ...params,
    plugins,
  });
  if (params.config.forkTSChecker) {
    let forkTypeChecker = new import_forkTSChecker.ForkTSChecker({
      root: params.root,
      watch: params.watch,
    });
    forkTypeChecker.runTypeCheckInChildProcess();
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 &&
  (module.exports = {
    build,
  });
